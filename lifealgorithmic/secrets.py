#! /usr/bin/env python3 

"""
Library for generating and managing copy-and-paste confirmation messages.
"""

import base64
import hashlib
from os import stat 
import platform
import getpass 
import json 
import datetime
import argparse
import subprocess 
import nacl.secret
import nacl.exceptions
import platform 
import getpass 
import pathlib
import os 
import typing
import sys 
import getpass


# Python 3.6 does not initialize sys.argv in embedded mode. 
if sys.version_info[0:2] == (3,6) and not hasattr(sys, 'argv'):
    sys.argv = [str(pathlib.Path(sys.executable).name)]
if sys.version_info[0:2] == (3,7):
    sys.argv = [str(pathlib.Path(sys.executable).name)]

class Secret:
    """
    Access to secret codes and data files.
    """

    def __init__(self, key :str = None, file :str = None):
        self.data = {}
        self.data['user'] = getpass.getuser()
        self.data['host'] = platform.node()
        self.data['cmd'] = sys.argv[0]
        self.data['date'] = round(datetime.datetime.now(datetime.timezone.utc).timestamp())
        self.key = None
        self.file = None
        if key is None:
            self.key = self.nodehash()
        else:
            self.setkey(key)
        if file is not None:
            self.setfile(file)

    def setkey(self, key :str):
        self.key = hashlib.blake2b(key.encode('utf-8'), digest_size=nacl.secret.SecretBox.KEY_SIZE).digest()
        self.box = nacl.secret.SecretBox(self.key)

    def setfile(self, file :str):
        self.file = pathlib.Path(file)
        self.load()

    def store(self):
        self.data['date'] = round(datetime.datetime.now(datetime.timezone.utc).timestamp())
        if self.file is not None:
            with open(self.file, 'wb') as fh:
                fh.write(self.box.encrypt(json.dumps(self.data).encode('utf-8')))

    def load(self, validate=True):
        if self.file is not None:
            if not self.file.exists():
                self.store()
            else:
                try:
                    with open(self.file, 'rb') as fh:
                        self.data = json.loads(self.box.decrypt(fh.read()).decode('utf-8'))
                    if validate:
                        assert self.data['user'] == getpass.getuser()
                        assert self.data['host'] == platform.node()
                        assert self.data['cmd'] == sys.argv[0]
                except (KeyError, AssertionError, nacl.exceptions.CryptoError) as e:
                    # Nuke the bad file.                    
                    self.store()

    def get(self, key: typing.Hashable, default: object = None):
        return self.data.get(key, default)

    def put(self, key: typing.Hashable, value: object):
        self.data[key] = value
        self.store() 

    def confirmation(self, data) -> str:
        """
        Generate a b64 encoded JSON object with an embedded authentication hash. 
        """
        data['user'] = getpass.getuser()
        data['host'] = platform.node()
        data['cmd'] = sys.argv[0]
        data['date'] = round(datetime.datetime.now(datetime.timezone.utc).timestamp())
        raw = json.dumps(data, separators=(',', ':')).encode('utf-8')
        h = hashlib.blake2b(raw, digest_size=8, key=self.key)
        return base64.b64encode(h.digest() + raw).decode('utf-8')

    def validate(self, cfm: str) -> object: 
        """
        Validate a confirmation number generated by `generate`. 

        Returns the dictionary object with the date nicely converted. Raises an 
        exception if there was a validation error.     
        """

        raw = base64.b64decode(cfm)
        assert len(raw) > 8, '**GARBAGE**'
        ah = hashlib.blake2b(raw[8:], digest_size=8, key=self.key).digest()
        assert ah == raw[0:8], '**TAMPER**'
        data = json.loads(raw[8:])
        data['date'] = datetime.datetime.fromtimestamp(data['date']).strftime("%a %b %d, %Y %I:%M %p")
        return data

    def nodehash(self):
        """
        Get a unique hash for this machine. 
        """
        interface = subprocess.run('ip route | grep default | cut -f5 -d" "', 
            shell=True, stdout=subprocess.PIPE).stdout.decode('utf-8').strip()

        with open(f'/sys/class/net/{interface}/address') as fh:
            mac = fh.read()

        return hashlib.blake2b(mac.encode('utf-8'), 
            digest_size=nacl.secret.SecretBox.KEY_SIZE).digest()

def main():
    """
    Decode confirmation numbers from stdin.
    """

    parser = argparse.ArgumentParser(description="Process confirmation numbers from stdin.")
    parser.add_argument('-k', '--key', type=str, required=True, help="The key used for operations.")
    parser.add_argument('-f', '--file', type=str, help="The encrypted file to read.")

    args = parser.parse_args()

    vault = Secret(key=args.key)

    Bold = "\x1b[1m"
    Reset = "\x1b[0m"
    F_LightGreen = "\x1b[92m"
    F_Default = "\x1b[39m"
    B_Default = "\x1b[49m"
    B_Black = "\x1b[40m"

    if args.file is None:
        while True:
            got = input('> ')
            for word in got.split():
                try:
                    data = vault.validate(word)
                    print("\n")
                    print(Bold, F_LightGreen, B_Black, sep='', end='')
                    print(data)
                    print(B_Default, F_Default, Reset, sep='', end='')                    
                    print("\n")
                except Exception as e:
                    pass
    else:
        if args.file is None:
            raise ValueError("You must specify a file.")
        with open(args.file, 'rb') as fh:
            print(json.loads(vault.box.decrypt(fh.read()).decode('utf-8')))

#
# Singleton 
# 
vault = Secret()

if __name__ == '__main__':
    main() 
