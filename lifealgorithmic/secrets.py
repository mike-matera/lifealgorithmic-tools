"""
Library for generating and managing copy-and-paste confirmation messages.
"""

import base64
import hashlib 
import platform
import getpass 
import json 
import datetime
import argparse 
import nacl.secret


def genkey(key: str, keysize :int = nacl.secret.SecretBox.KEY_SIZE) -> bytes:
    """
    Generate an encryption key from a phrase using BLAKE2. 
    """
    return hashlib.blake2b(key.encode('utf-8'), digest_size=keysize).digest()


def load_file(filename: str, key: str) -> object:
    """
    Load an encrypted JSON file. 
    """
    box = nacl.secret.SecretBox(genkey(key))
    with open(filename, 'rb') as fh:
        return json.loads(box.decrypt(fh.read()).decode('utf-8'))


def store_file(filename: str, key: str, data: object) -> None:
    """
    Save an encrypted JSON file.
    """    
    box = nacl.secret.SecretBox(genkey(key))
    with open(filename, 'wb') as fh:
        fh.write(box.encrypt(json.dumps(data).encode('utf-8')))


def generate_code(data: object, key: str) -> str:
    """
    Generate a b64 encoded JSON object with an embedded authentication hash. 

    The value in object must be JSON serializable. The key is used to make 
    the hash and must be kept secret. Some keys will automatically be added
    to the data:

        - host 
        - user
        - date
    """

    if isinstance(data, dict):
        data = dict(data)
    else:
        data = { 'data': data }
    data['host'] = platform.node()
    data['user'] = getpass.getuser()
    data['date'] = datetime.datetime.now(datetime.timezone.utc).timestamp()

    raw = json.dumps(data, separators=(',', ':')).encode('utf-8')
    h = hashlib.blake2b(raw, digest_size=8, key=key.encode('utf-8'))
    return base64.b64encode(h.digest() + raw).decode('utf-8')


def validate_code(cfm: str, key: str) -> object: 
    """
    Validate a confirmation number generated by `generate`. 

    Returns the dictionary object with the date nicely converted. Raises an 
    exception if there was a validation error.     
    """

    raw = base64.b64decode(cfm)
    assert len(raw) > 8, '**GARBAGE**'
    ah = hashlib.blake2b(raw[8:], digest_size=8, key=key.encode('utf-8')).digest()
    assert ah == raw[0:8], '**TAMPER**'
    data = json.loads(raw[8:])
    data['date'] = datetime.datetime.fromtimestamp(data['date']).strftime("%a %b %d, %Y %I:%M %p")
    return data


def main():
    """
    Decode confirmation numbers from stdin.
    """

    parser = argparse.ArgumentParser(description="Process confirmation numbers from stdin.")
    parser.add_argument('command', choices=('confirm', 'file'), help='Run confirmation number or file operations.')
    parser.add_argument('-k', '--key', type=str, help="The key used for operations.")
    parser.add_argument('-f', '--file', type=str, help="The encrypted file to read.")

    args = parser.parse_args()

    if args.command == 'confirm':
        while True:
            try:
                print(validate_code(input('> '), args.key))
            except Exception as e:
                print("Error:", e)
    else:
        if args.file is None:
            raise ValueError("You must specifiy a file.")
        print(load_file(args.file, args.key))


if __name__ == '__main__':
    main() 
