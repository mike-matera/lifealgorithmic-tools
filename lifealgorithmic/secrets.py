"""
Library for generating and managing copy-and-paste confirmation messages.
"""

import base64
import hashlib
from os import stat 
import platform
import getpass 
import json 
import datetime
import argparse 
import nacl.secret
import nacl.exceptions
import platform 
import getpass 
import pathlib
import os 
import typing
import csv 

class Secret:
    """
    Access to secret codes and data files.
    """

    def __init__(self, key :str = None, file :str = None):
        self.data = {}
        self.data['user'] = getpass.getuser()
        self.data['host'] = platform.node()
        self.data['date'] = round(datetime.datetime.now(datetime.timezone.utc).timestamp())
        self.key = None
        self.file = None
        if key is not None:
            self.setkey(key)
        if file is not None:
            self.setfile(file)

    def setkey(self, key :str):
        self.key = hashlib.blake2b(key.encode('utf-8'), digest_size=nacl.secret.SecretBox.KEY_SIZE).digest()

    def setfile(self, file :str):
        self.file = pathlib.Path(file)
        self.box = nacl.secret.SecretBox(self.key)
        self.load()

    def store(self):
        self.data['date'] = round(datetime.datetime.now(datetime.timezone.utc).timestamp())
        if self.file is not None:
            with open(self.file, 'wb') as fh:
                fh.write(self.box.encrypt(json.dumps(self.data).encode('utf-8')))

    def load(self, validate=True):
        if self.file is not None:
            if not self.file.exists():
                self.store()
            else:
                try:
                    with open(self.file, 'rb') as fh:
                        self.data = json.loads(self.box.decrypt(fh.read()).decode('utf-8'))
                    if validate:
                        assert self.data['user'] == getpass.getuser()
                        assert self.data['host'] == platform.node()
                except (AssertionError, nacl.exceptions.CryptoError) as e:
                    # Nuke the bad file.                    
                    self.store()

    def get(self, key: typing.Hashable, default: object = None):
        return self.data.get(key, default)

    def put(self, key: typing.Hashable, value: object):
        self.data[key] = value
        self.store() 

    def confirmation(self, data) -> str:
        """
        Generate a b64 encoded JSON object with an embedded authentication hash. 
        """
        data['user'] = getpass.getuser()
        data['host'] = platform.node()
        data['date'] = round(datetime.datetime.now(datetime.timezone.utc).timestamp())
        raw = json.dumps(data, separators=(',', ':')).encode('utf-8')
        h = hashlib.blake2b(raw, digest_size=8, key=self.key)
        return base64.b64encode(h.digest() + raw).decode('utf-8')

    def validate(self, cfm: str) -> object: 
        """
        Validate a confirmation number generated by `generate`. 

        Returns the dictionary object with the date nicely converted. Raises an 
        exception if there was a validation error.     
        """

        raw = base64.b64decode(cfm)
        assert len(raw) > 8, '**GARBAGE**'
        ah = hashlib.blake2b(raw[8:], digest_size=8, key=self.key).digest()
        assert ah == raw[0:8], '**TAMPER**'
        data = json.loads(raw[8:])
        data['date'] = datetime.datetime.fromtimestamp(data['date']).strftime("%a %b %d, %Y %I:%M %p")
        return data

    def nodehash(self):
        """
        Get a unique number for this machine.
        """

        with open('/proc/net/route') as fh:
            interface = None
            data = csv.reader(fh, delimiter='\t')
            for row in data:
                try:
                    if int(row[2], base=16) != 0:
                        interface = row[0]
                        break
                except:
                    pass
        with open(f'/sys/class/net/{interface}/address') as fh:
            mac = fh.read()

        h = hashlib.blake2b(mac.encode('utf-8'), digest_size=8, key=self.key)
        return int.from_bytes(h.digest(), byteorder='big')

def main():
    """
    Decode confirmation numbers from stdin.
    """
    global vault

    parser = argparse.ArgumentParser(description="Process confirmation numbers from stdin.")
    parser.add_argument('-k', '--key', type=str, help="The key used for operations.")
    parser.add_argument('-f', '--file', type=str, help="The encrypted file to read.")

    args = parser.parse_args()

    vault.setkey(args.key)
    if args.file is None:
        while True:
            try:
                print(vault.validate(input('> ')))
            except Exception as e:
                print("Error:", e)
    else:
        if args.file is None:
            raise ValueError("You must specifiy a file.")
        vault.setfile(args.file)
        print(vault.data)

#
# Singleton 
# 
vault = Secret()

if __name__ == '__main__':
    main() 
